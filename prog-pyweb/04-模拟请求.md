# 网页解析

## 1. 访问

### 1.1. 请求与响应

 `Requests` 基于 `urllib3` ，即多次请求重复使用一个 socket。

```python
import requests
# 所有的方法均是调用 requests(url) 完成
## requests.requests(url)

# GET
kv = {'wd': 'python'}
url = 'http://www.baidu.com/s'
r = requests.request('GET', url, params=kv)
print(r.url)
'http://www.baidu.com/s?wd=python'

# POST
r = requests.request('POST', url, params=kv)
## data
r = requests.request('POST', url, data=kv)
## json
r = requests.request('POST', url, json=kv)
## headers
hd = {'user-agent': 'Chrome/10'}
r = requests.request('POST', url, headers=hd)
## files
fs = {'file': open('data.xls', 'rb')}
r = requests.request('POST', url, files=fs)

# 响应
r = requests.get(url)
## r.text 返回的是 Unicode 型的数据
html = r.text
## 获得真实编码
r.apparent_encoding
## 设定编码
r.encoding='utf-8'

print(r.status_code)
print(r.text)
print(r.cookies)
# header 编码
print(r.encoding)
# 内容编码
print(r.apparent_encoding)
print(r.content)
```

### 1.2. 保存与编码

```python
import os

root = '/Downloads'
path = root + url.split('/')[-1]

try:
    if not os.path.exists(root):
        os.mkdir(root)
    if not os.path.exists(path):
        r = requests.get(url)
        ## r.text 为 str
        with open('test.html', 'w', encoding="utf-8") as f:
            f.write(r.text)
        ## r.content 为 bytes 型
        with open('test.html', 'wb') as f:
            r.encoding = r.apparent_encoding
        # r.content 为二进制形式
        f.write(r.content)
        f.close()
    else:
        print('file exists')
except:
    print('failure')
```

### 1.3. 异常与超时

```python
import requests
import time

def get_html(url):
    try:
        r = requests.get(url, timeout=30)
        # 返回异常
        r.raise_for_status()
        r.encoding = r.apparent_encoding
        return r.text
    except:
        return 'Error'

if __name__ == "__main__":
    url = "https://www.baidu.com"
    begin = time.time()
    get_html(url)
    end = time.time()

requests.get('http://github.com', timeout=0.001)
```

### 1.4. 重定向和流

```python
# 重定向
r = requests.head('http://github.com', allow_redirects=True)
r.url
'https://github.com/'
r.history
[<Response [301]>]

# 立即下载
tarball_url = 'https://github.com/kennethreitz/requests/tarball/master'
r = requests.get(tarball_url, stream=True)
```

### 1.5. 代理

若需要使用代理，可通过为任意请求方法提供 `proxies` 参数来配置单个请求:

```python
import requests

proxies = {"http": "http://10.10.1.10:3128", "https": "http://10.10.1.10:1080", }
requests.get("http://example.org", proxies=proxies)

# 也可通过环境变量 HTTP_PROXY 和 HTTPS_PROXY 来配置代理。
! export HTTP_PROXY="http://10.10.1.10:3128"
! export HTTPS_PROXY="http://10.10.1.10:1080"

requests.get("http://example.org")

# 若代理需要使用 HTTP Basic Auth，可使用 http://user:password@host/
proxies = {
  "http": "http://user:pass@10.10.1.10:3128/", 
}

# 要为某个特定的连接方式或者主机设置代理，使用 scheme://hostname 作为 key， 它会针对指定的主机和连接方式进行匹配。
proxies = {'http://10.20.1.128': 'http://10.10.1.10:5323'}

# 使用 SOCKS 代理和使用 HTTP 代理一样简单：
proxies = {'http': 'socks5://user:pass@host:port', 
'https': 'socks5://user:pass@host:port'}
```

### 1.6. 响应头链接字段

许多 HTTP API 都有响应头链接字段的特性，它们使得 API 能够更好地自我描述和自我显露。GitHub 在 API 中为 分页 [http://developer.github.com/v3/#pagination] 使用这些特性，例如：

```python
url = 'https://api.github.com/users/kennethreitz/repos?page=1&per_page=10'
r = requests.head(url=url)
r.headers['link']

# requests 会自动解析这些响应头链接字段，并使得它们非常易于使用:
r.links["next"]
{'url': 'https://api.github.com/users/kennethreitz/repos?page=2&per_page=10', 'rel': 'next'}
r.links["last"]
```

## 2. 会话

### 2.1. cookie

Cookie 是指某些网站服务器为了辨别用户身份和进行 `Session` 跟踪，而储存在用户浏览器上的文本文件，Cookie 可保持登录信息到用户下次与服务器的会话

```python
url = 'http://example.com/some/cookie/setting/url'
r = requests.get(url)
# 获取 cookie
r.cookies['example_cookie_name']
'example_cookie_value'

# 发送 cookies 到服务器：使用 cookies 参数：
url = 'http://httpbin.org/cookies'
cookies = dict(cookies_are='working')
r = requests.get(url, cookies=cookies)
r.text
'{"cookies": {"cookies_are": "working"}}'

# Cookie 的返回对象为 requestsCookieJar，它的行为和字典类似，但接口更为完整，适合跨域名跨路径使用
jar = requests.cookies.requestsCookieJar()
jar.set('tasty_cookie', 'yum', domain='httpbin.org', path='/cookies')
jar.set('gross_cookie', 'blech', domain='httpbin.org', path='/elsewhere'
url = 'http://httpbin.org/cookies'
r = requests.get(url, cookies=jar)
r.text
'{"cookies": {"tasty_cookie": "yum"}}'
```

### 2.2. 会话对象

会话对象让你能够跨请求保持某些参数。它也会在同一个 `Session` 实例发出的所有请求之间保持 cookie。所以若你向同一主机发送多个请求，底层的 TCP 连接将会被重用，从而带来显著的性能提升。 会话对象具有 requests API 的所有方法。

```python
s = requests.Session()
s.get('http://httpbin.org/cookies/set/sessioncookie/123456789')
r = s.get("http://httpbin.org/cookies")

print(r.text)
# '{"cookies": {"sessioncookie": "123456789"}}'

# 为请求方法提供缺省数据
s.auth = ('user', 'pass')
s.headers.update({'x-test': 'true'})
### both 'x-test' and 'x-test2' are sent
s.get('http://httpbin.org/headers', headers={'x-test2': 'true'})

# 任何你传递给请求方法的字典都会与已设置会话层数据合并。方法层的参数覆盖会话的参数。
r = s.get('http://httpbin.org/cookies', cookies={'from-my': 'browser'})
print(r.text)
### '{"cookies": {"from-my": "browser"}}'
r = s.get('http://httpbin.org/cookies')
print(r.text)
### '{"cookies": {}}'

# 用作前后文管理器
with requests.Session() as s:
  s.get('http://httpbin.org/cookies/set/sessioncookie/123456789')

# 准备请求
from requests import Request, Session

s = Session()
req = Request('GET', url, data=data, headers=header)
prepped = s.prepare_request(req)
# do something with prepped.body
# do something with prepped.headers
resp = s.send(prepped, stream=stream, verify=verify, proxies=proxies, 
cert=cert, timeout=timeout)
print(resp.status_code)
```

### 2.3. 证书

 `requests` 默认附带了一套它信任的根证书，来自于 Mozilla trust store
[https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt]。然而它们在每次 requests 更新时才会更新。

```python
# 认证 SSL
requests.get('https://github.com', verify=True)
## verify = False，requests 可忽略对 SSL 证书的验证
requests.get('https://github.com', verify='/path/to/certfile')

# 本地证书用作客户端证书，可是单个文件（包含密钥和证书） 或一个包含两个文件路径的元组
requests.get('https://kennethreitz.org', cert = ('/path/client.cert', '/path/client.cert')
```

## 3. 身份认证

### 3.1. 基本认证

许多要求身份认证的 web 服务都接受 HTTP Basic Auth。这是最简单的一种身份认证，且 `requests` 对这种认证方式的支持是直接开箱即可用。以 HTTP Basic Auth 发送请求非常简单：

```python
from requests.auth import HTTPBasicAuth

requests.get('https://api.github.com/user', 
 auth=HTTPBasicAuth('user', 'pass'))

## <Response [200]>
```

### 3.2. 摘要式认证

另一种非常流行的 HTTP 身份认证形式是摘要式身份认证， `requests` 对它的支持亦为开箱即可用的：

```python
from requests.auth import HTTPDigestAuth

url = 'http://httpbin.org/digest-auth/auth/user/pass'
requests.get(url, auth=HTTPDigestAuth('user', 'pass'))
## <Response [200]>

from requests_oauthlib import OAuth1

url = 'https://api.twitter.com/1.1/account/verify_credentials.json'
auth = OAuth1('YOUR_APP_KEY', 'YOUR_APP_SECRET', ...
  'USER_OAUTH_TOKEN', 'USER_OAUTH_TOKEN_SECRET')
requests.get(url, auth=auth)
## <Response [200]>
```

### 3.3. 新身份认证

若你找不到所需要的身份认证形式的一个良好实现，你也可自己实现它。

 `requests` 非常易于添加你自己的身份认证形式。要想自己实现，就从 `AuthBase` 继承一个子类，并实现 `__call__()` 方法：

```python
import requests

class MyAuth(requests.auth.AuthBase):
  def __call__(self, r):
  # Implement my authentication
    return r

url = 'http://httpbin.org/get'
requests.get(url, auth=MyAuth())
## <Response [200]>
```

## 4. 数据交互

### 4.1. 分块编码请求

对于出去和进来的请求， `requests` 支持分块传输编码。要发送一个块编码的请求，仅需为你的请求体提供一个生成器（或任意没有具体长度的迭代器）。

```python
def gen():
  yield 'hi'
  yield 'there'

requests.post('http://some.url/chunked', data=gen())

# POST 多个分块编码的文件
## 你可在一个请求中发送多个文件。例如，设你要上传多个图像文件到一个 HTML 表单，使用一个多文件 field 叫做 “images”:
<input type="file" name="images" multiple="true" required="true"/>

## 要实现，只要把文件设到一个元组的列表中，其中元组结构为 (form_field_name, file_info)
url = 'http://httpbin.org/post'
multiple_files = [('images', ('foo.png', open('foo.png', 'rb'), 'image/png')), ('images', ('bar.png', open('bar.png', 'rb'), 'image/png'))]
r = requests.post(url, files=multiple_files)
r.text
{
  ...
  'files': {'images': 'data:image/png;base64, iVBORw ....'}
  'Content-Type': 'multipart/form-data; boundary=3131623adb2043caaeb5538cc7aa0b3a', 
  ...
}
```

### 4.2. 事件钩子

 `requests` 有一个钩子系统，你可用于操控部分请求过程，或信号事件处理。

```python
可用的钩子:
response:
  从一个请求产生的响应

# 可通过传递一个 {hook_name: callback_function} 字典给 hooks 请求参数为每个请求分配一个钩子函数：
hooks=dict(response=print_url)

# callback_function 会接受一个数据块作为它的第一个参数。
def print_url(r, *args, **kwargs):
  print(r.url)

# 若回调函数返回一个值，默认以该值替换传进来的数据。若函数未返回任何东西，也没有什么其他的影响。
# 在运行期间打印一些请求方法的参数：
requests.get('http://httpbin.org', hooks=dict(response=print_url))
## http://httpbin.org
## <Response [200]>
```

### 4.3. 流式请求

使用 `Response.iter_lines()` 可很方便地对流式 API （例如 Twitter 的流式 API[https://dev.twittercom/docs/streaming-api] ） 进行迭代。简单地设置 `stream` 为 `True` 便可使用 `iter_lines` 对相应进行迭代：

```python
import json
import requests
r = requests.get('http://httpbin.org/stream/20', stream=True)
for line in r.iter_lines():
  # filter out keep-alive new lines
  if line:decoded_line = line.decode('utf-8')
 print(json.loads(decoded_line))

# 当使用 decode_unicode=True 在 Response.iter_lines() 或 Response.iter_content() 中时，需要提供一个回退编码方式，以防服务器没有提供默认回退编码，从而导致错误：
if r.encoding is None:
  r.encoding = 'utf-8'
for line in r.iter_lines(decode_unicode=True):
  if line:
 print(json.loads(line))

# iter_lines 不保证重进入时的安全性。多次调用该方法 会导致部分收到的数据丢失。若你要在多处调用它，就应该使用生成的迭代器对象:
lines = r.iter_lines()
## 保存第一行以供后面使用，或者直接跳过
first_line = next(lines)
for line in lines:
  print(line)
```

## 5. 微服务

### 5.1. 验证

很多新式 API 在使用之前都要求客户验证。有些 API 要求客户验证是为了计算 API 调用的费用，或者是提供了包月的服务。有些验证是为了"限制"用户使用 API（限制每秒钟、每小时或每天 API 调用的次数），或者是限制一部分用户对某种信息或某类 API 的访问。还有一些 API 可能不要求验证，但，可能会为了市场营销而跟踪用户的使用行为。

通常 API 验证的方法均是用类似令牌（token）的方式调用，每次 API 调用都会把令牌传递到服务器上。这种令牌要么是用户注册的时候分配给用户，要么就是在用户调用的时候才提供，可能是长期固定的值，也可能是频繁变化的，通过服务器对用户名和密码的组合处理后生成。

令牌除了在 URL 链接中传递，还会通过请求头里的 cookie 把用户信息传递给服务器。

```python
token = "<your api key>"
html = requests.post("http://myapi.com", headers={"token":token}).text
```

### 5.2. 处理 JSON

Python 把 JSON 转换成字典，JSON 数组转换成列表，JSON 字符串转换成 unicode 字符串。通过这种方式，可让 JSON 的获取和操作变得非常简单。

```python
import requests
import json

## 读取
def getCountry(ipAddress):
    url = "http://freegeoip.net/json/"+ipAddress
    html = requests.get(url).text
    html_json = json.loads(html)
    
    return html_json.get("country_code")

print(getCountry("50.78.253.58"))

# 将 Python 对象转换为 JSON 字符串
jsonString = '{"arrayOfNums": [{"number":0}, {"number":1}, {"number":2}], "arrayOfFruits": [{"fruit":"apple"}, {"fruit":"banana"}, {"fruit":"pear"}]}'

jsonObj = json.loads(jsonString)
print(jsonObj.get("arrayOfNums"))
[{'number': 0}, {'number': 1}, {'number': 2}]

print(jsonObj.get("arrayOfNums")[1])
{'number': 1}

print(jsonObj.get("arrayOfNums")[1].get("number")+
jsonObj.get("arrayOfNums")[2].get("number"))
3

print(jsonObj.get("arrayOfFruits")[2].get("fruit"))
pear
```
